<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on nothing</title><link>https://blog.nidhoggfgg.fun/tags/rust/</link><description>Recent content in Rust on nothing</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 14 Nov 2022 20:54:27 +0800</lastBuildDate><atom:link href="https://blog.nidhoggfgg.fun/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>终端输出甜甜圈</title><link>https://blog.nidhoggfgg.fun/post/1a2d7e39/</link><pubDate>Mon, 14 Nov 2022 20:54:27 +0800</pubDate><guid>https://blog.nidhoggfgg.fun/post/1a2d7e39/</guid><description>前言 这篇文章是在看了 how donut.c works 之后写的，或许这篇文章应该叫做《在 Rust 中复刻 donut.c》。 但由于会完全解释背后的数学原理，并且在 Rust 中实现一个更强的版本 (增强 3D 效果和添加颜色，自动适配终端大小等)，并在最后对 Rust 代码做一点混淆。 我一下子不知道该取什么标题，干脆就叫终端输出甜甜圈这样看起来文不对题的标题。
假如不知道 donut.c 运行输出的效果，下面这个是我在 Rust 中完全复刻输出的效果:
这个是已经增强了光照的，在只有不到 8 fps 的 gif 中效果大打折扣，实际在终端中几十帧的时候相当不错。
总体上来说这篇文章分为两部分，第一部分会详细地介绍背后的数学原理，第二部分会一步步用 Rust 代码实现。 第一部分与原作者不同，我不仅会给出该怎么做，还会给出为什么这么做。 第二部分在用 Rust 实现了 donut 的基础上会选择增强效果以及和原作者一样给出一个混淆的源代码。 混淆后的源代码如下:
use std::{ time, thread,f64};fn main(){let s =f64::consts::PI;let (w,h)= (60,26 );let k= 30.0;let mut l=Vec::new();for i in 0..=11{let c=&amp;#34;.,-~:;=!*#$@&amp;#34;.chars().nth(i) .unwrap();let s=format!(&amp;#34;\x1B[38;5;{}m{}&amp;#34;,233+2*i ,c);l.push(s);} let(mut a,mut b)=(0.0_f64,0.0_f64); println!( &amp;#34;\x1B[2J&amp;#34;); loop {let((c,i),(j,q))=(a. sin_cos(),b.sin_cos( ));let(mut o,mut m) = ( vec!</description></item></channel></rss>