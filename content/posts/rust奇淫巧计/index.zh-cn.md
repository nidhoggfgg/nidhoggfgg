---
title: "Rust奇淫巧计"
date: 2024-02-16T18:40:45+08:00
draft: true
lastmod: 2024-02-16
slug: 9e467e80
categories:
    - Rust
tags:
    - Rust
---

## 编译错误背后的原理

### 传递二维 Vec

在阅读《The book》时，书中说需要传递 `Vec<T>` 且不用传递所有权时可以使用 `&[T]`，也就是切片。
而且这种切片类型会提供更多的兼容性，比如可以传入 `[T]`。
这在各种编程语言中已经是屡见不鲜，但是考虑切片背后的内存布局，切片并不简单。

考虑以下代码，
```rust
#[allow(unused)]
fn main() {
    let v = vec![vec![0]];
    test(&v)
}

fn test(s: &[&[i32]]) {}
```

会得到如下编译错误：

```
error[E0308]: mismatched types
 --> examples/test.rs:4:10
  |
4 |     test(&v)
  |     ---- ^^ expected `&[&[i32]]`, found `&Vec<Vec<{integer}>>`
  |     |
  |     arguments to this function are incorrect
  |
  = note: expected reference `&[&[i32]]`
             found reference `&Vec<Vec<{integer}>>`
note: function defined here
 --> examples/test.rs:7:4
  |
7 | fn test(s: &[&[i32]]) {}
  |    ^^^^ ------------
```

为什么按照书中将 `&Vec<T>` 传递给 `&[T]` 没问题，而照猫画虎传入二维向量就不行了。

#### 切片寻根溯源

首先实际上在 rust 中 `[T]` 应当被称为切片，而 `&[T]` 是切片的引用。
但是一般在不混淆的时候 `&[T]` 称为切片没有问题，因为 `[T]` 是编译期不确定大小的，不能直接使用的。
值得注意的是，平时一般使用的是 `[T; n]` 这是一个 `Sized` 类型，称为 `array`。

接下来考虑它们的内存布局。

首先是 `[T]`:
```
+-+-+-+-+-+-+
|T|T|T|T|T|T| ......
+-+-+-+-+-+-+
```
以及 `&[T]`:
```
+-------+------+
|pointer|length| 在栈上
+-------+------+
    |
    +--+
       | 指向起始位置
       v
+-+-+-+-+-+-+
|T|T|T|T|T|T| ......
+-+-+-+-+-+-+
```
由此可以看出，`&[T]` 是一个指针，而且是胖指针，后面附带的 length 是长度信息。

最后再来分析 `Vec<T>` 的内存，下面的内存布局摘抄自官方的 std 文档
```
            ptr      len  capacity
       +--------+--------+--------+
       | 0x0123 |      2 |      4 |
       +--------+--------+--------+
            |
            v
Heap   +--------+--------+--------+--------+
       |    'a' |    'b' | uninit | uninit |
       +--------+--------+--------+--------+
```
`Vec<T>` 也是一个胖指针，但是和 `&[T]` 是完全不一样的，它多了一个 capacity。
所以它们类型完全不同，内存中的布局也不同。

可是现在又有了新的问题，既然 `Vec<T>` 和 `&[T]` 不同，为什么可以将 `&Vec<T>` 当作 `&[T]` 传递？

这是因为 `Vec<T>` 不是一个普通的指针，它是一个智能指针。所谓智能就是可以在需要的时候当作一般的引用来使用。
对于 `Vec<T>` 实现了 `Deref<Target = [T]>` 即可以自动解引用为 `[T]`!
而具体的内部实现就不详细讨论了。

到了这里，可以看出传入 `&Vec<Vec<T>>` 是不可能被当作 `&[&[T]]` 的，它们的内存布局上的区别如下
```
Vec<Vec<T>>:
+---+---+---+
|ptr|len|cap|
+---+---+---+
  |
  v
+---+---+---+---+---+---+
|ptr,len,cap|ptr,len,cap| ...... 注意看这里
+---+---+---+---+---+---+
  |           |
  v           |
+-+-+-+       |
|T|T| |...... |
+-+-+-+       |
              V
             +-+-+-+-+-+-+
             |T|T|T|T| | | ......
             +-+-+-+-+-+-+

&[&[T]]:
+---+---+
|ptr|len|
+---+---+
  |
  v
+---+---+---+---+
|ptr,len|ptr,len| ...... 注意看这里
+---+---+---+---+
  |           |
  v           |
+-+-+-+       |
|T|T| |...... |
+-+-+-+       |
              V
             +-+-+-+-+-+-+
             |T|T|T|T| | | ......
             +-+-+-+-+-+-+
```
可以看出，它们在栈上的内存是不一致的，它们没办法兼容！

#### 解决方案