<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Shell中的奇淫巧技</title><link rel=stylesheet href=/style.min.css></head><body><header class=site-header><div class=logo><svg fill="#909090" t="1651558285715" class="icon" viewBox="0 0 1034 1024" xmlns="http://www.w3.org/2000/svg" p-id="4913" width="200" height="200"><path d="M922.757 679.722c-9.278-52.003-24.544-99.516-43.39-139.068.091-.137.182-.275.275-.408.847.258 1.696.508 2.541.773-.422-.883-.863-1.76-1.292-2.643 12.366-18.578 22.399-39.972 29.136-66.647 3.516-13.909 6.145-29.263 7.783-46.397.818-8.569 1.389-17.584 1.698-27.092.156-4.751.246-9.626.269-14.633.022-5.002-.022-10.14-.133-15.402.081-10.857-.111-21.828-.471-32.944-.359-11.116-.885-22.367-1.475-33.786-1.178-22.837-2.604-46.319-3.434-70.643-1.523-34.468-1.834-70.638-2.67-105.163-19.341 6.757-39.436 15.327-59.56 25.448-81.158 40.989-166.211 107.387-215.76 191.069-1.042 1.655-2.046 3.322-3.049 4.986-38.35-10.217-79.226-15.743-121.656-15.743-43.438.0-85.243 5.795-124.381 16.487-.939-1.447-1.869-2.891-2.834-4.33-53.276-84.088-134.112-149.982-215.583-191.043-20.062-10.118-40.164-18.696-59.515-25.452-.839 34.537-1.153 70.724-2.677 105.213-1.663 48.665-5.701 93.985-5.376 137.427-1.778 83.493 13.639 133.437 39.644 171.555-.142.303-.294.602-.437.905.139-.038.277-.075.416-.112-18.356 39.116-33.223 85.823-42.326 136.86-2.678 15.01-4.747 29.82-6.254 44.359 65.632 10.539 144.907 36.168 225.818 75.514 55.879 27.177 105.924 57.687 147.427 88.735 3.259 3.722 7.779 7.212 12.852 10.232 5.65 3.36 11.912 6.11 17.756 7.969 2.927.931 5.759 1.64 8.428 2.108 1.336.237 2.633.412 3.885.526.625.052 1.241.096 1.846.115.605.021 1.2.027 1.78.018 11.043-.218 22.754-6.308 32.935-14.805h.439c43.386-33.658 97.033-66.961 157.499-96.36 80.923-39.35 160.207-64.979 225.863-75.526-1.484-13.815-3.485-27.877-6.022-42.109zM682.665 760.403c-54.102 27.67-102.101 59.014-140.921 90.693h-.392c-9.11 7.996-19.587 13.728-29.469 13.934-.52.007-1.052.003-1.594-.017-.541-.021-1.09-.059-1.652-.109-1.121-.106-2.282-.27-3.476-.495-2.389-.442-4.923-1.108-7.54-1.985-5.229-1.75-10.831-4.338-15.887-7.5-4.539-2.842-8.584-6.126-11.5-9.63-37.133-29.222-81.911-57.936-131.909-83.515C265.93 724.746 195 700.628 136.278 690.706c1.348-13.683 3.2-27.623 5.597-41.749 7.07-41.692 18.023-80.317 31.533-113.864 11.924-1.751 24.096-2.671 36.471-2.671 143.697.0 261.084 115.913 274.521 266.783h.074c1.127 17.839 12.971 31.877 27.428 31.877 15.201.0 27.523-15.518 27.523-34.659.0-2.258-.177-4.463-.505-6.602 19.173-146.753 126.643-260.464 267.536-260.464 13.608.0 26.973 1.105 40.032 3.213 14.126 34.29 25.577 74.068 32.88 117.121 2.272 13.395 4.061 26.629 5.39 39.631-58.742 9.924-129.68 34.047-202.086 71.082z" p-id="4914"/></svg><a href=/>moefox</a></div><div id=toggle-menu><svg fill="#909090" t="1651821526565" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="1919" width="200" height="200"><path d="M128 725.333333A42.666667 42.666667.0 00170.666667 768h682.666666a42.666667 42.666667.0 100-85.333333H170.666667A42.666667 42.666667.0 00128 725.333333zM128 512a42.666667 42.666667.0 0042.666667 42.666667h682.666666a42.666667 42.666667.0 100-85.333334H170.666667A42.666667 42.666667.0 00128 512zm42.666667-256a42.666667 42.666667.0 000 85.333333h682.666666a42.666667 42.666667.0 100-85.333333H170.666667z" fill="#959ba7" p-id="1920" style="--darkreader-inline-fill:#3f4447"/></svg></div></header><aside id=sidebar><ol id=main-menu class=menu><li><a href=/archives/><svg fill="#909090" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20" enable-background="new 0 0 20 20"><path d="M13 8H7c-.6.0-1-.4-1-1s.4-1 1-1h6c.6.0 1 .4 1 1s-.4 1-1 1z"/><path d="M20 11.7l-3-10C16.8 1.3 16.4 1 16 1H4c-.4.0-.8.3-1 .7l-3 10s0 .2.0.3v6c0 .6.4 1 1 1h18c.6.0 1-.4 1-1v-6C20 11.9 20 11.8 20 11.7zM4.7 3h10.5l2.4 8H13c-.6.0-1 .4-1 1v1H8v-1c0-.6-.4-1-1-1H2.3L4.7 3zM18 17H2v-4h4v1c0 .6.4 1 1 1h6c.6.0 1-.4 1-1v-1h4v4z"/></svg><span>归档</span></a></li><li><a href=/search/><svg fill="#909090" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20" enable-background="new 0 0 20 20"><path d="M8 15c-3.9.0-7-3.1-7-7s3.1-7 7-7 7 3.1 7 7-3.1 7-7 7zM8 3C5.2 3 3 5.2 3 8s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5z"/><path d="M17.3 18.7l-3-3c-.4-.4-.4-1 0-1.4s1-.4 1.4.0l3 3c.4.4.4 1 0 1.4C18.3 19.1 17.7 19.1 17.3 18.7z"/></svg><span>搜索</span></a></li></ol></aside><main class=main><div class=container><article class=content><header><div class=article-title-wrapper><h1 class=article-title>Shell中的奇淫巧技</h1><div class=article-meta><div class=article-time><svg fill="#909090" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20" enable-background="new 0 0 20 20"><path d="M19 2h-3V0h-2v2H6V0H4v2H1C.4 2 0 2.4.0 3v16c0 .6.4 1 1 1h18c.6.0 1-.4 1-1V3C20 2.4 19.6 2 19 2zM18 18H2V4h16V18z"/><path d="M7.3 14.7l-2-2c-.4-.4-.4-1 0-1.4s1-.4 1.4.0L8 12.6l5.3-5.3c.4-.4 1-.4 1.4.0s.4 1 0 1.4l-6 6c-.4.4-1 .4-1.4.0z"/></svg><time>2022-05-07</time></div></div></div></header><section class=article><h2 id=前言>前言</h2><p>本文所有内容均在 bash 下进行，并且所说的 shell 都是指 bash，可能有一部分内容在 zsh 不起作用<br>文中所用到的 a 目录内容如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>a
</span></span><span class=line><span class=cl>├── test1
</span></span><span class=line><span class=cl>│   ├── test3.txt
</span></span><span class=line><span class=cl>│   └── test4.txt
</span></span><span class=line><span class=cl>├── test2
</span></span><span class=line><span class=cl>│   ├── test5.txt
</span></span><span class=line><span class=cl>│   └── test6.txt
</span></span><span class=line><span class=cl>├── .what
</span></span><span class=line><span class=cl>└── .why
</span></span><span class=line><span class=cl>    ├── .emmm
</span></span><span class=line><span class=cl>    └── emmm
</span></span></code></pre></td></tr></table></div></div><h2 id=奇淫巧技>奇淫巧技</h2><h3 id=模式扩展>模式扩展</h3><p>不使用 <code>pwd</code> 该如何获取当前所在目录呢，方法很多</p><ol><li>使用 <code>$PWD</code> 变量<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>使用 <code>dirname $(readlink -f $0)</code> 这样的神奇的指令<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></li><li>使用 <code>readlink -f .</code> 等等<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li></ol><p>但是更加罕见的是 <code>echo ~+</code> 这种形式<br>实际上这是 shell 的模式扩展（globbing），<code>~+</code> 默认扩展成当前目录，类似例子还有很多<br><code>~username</code> 扩展成 username 用户的主目录. 为空则默认为当前用户，这就是为什么 <code>~</code> 表示当前用户的主目录了<br>众所周知 <code>*</code> 可以匹配除了点以外的任意字符多次，实际上开启一个参数后点也可以匹配到，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>what@DESKTOP-EQ0RG58:~/a$ ls *
</span></span><span class=line><span class=cl>test1:
</span></span><span class=line><span class=cl>test3.txt  test4.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>test2:
</span></span><span class=line><span class=cl>test5.txt  test6.txt
</span></span><span class=line><span class=cl>what@DESKTOP-EQ0RG58:~/a$ shopt -s dotglob
</span></span><span class=line><span class=cl>what@DESKTOP-EQ0RG58:~/a$ ls *
</span></span><span class=line><span class=cl>.what
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>test1:
</span></span><span class=line><span class=cl>test3.txt  test4.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>test2:
</span></span><span class=line><span class=cl>test5.txt  test6.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.why:
</span></span><span class=line><span class=cl>emmm
</span></span></code></pre></td></tr></table></div></div><p><code>{} []</code> 这些东西可以匹配字符，实际上开启了 <code>extglob</code> 之后还可以设置匹配的次数</p><h3 id=_-与->$_ 与 :</h3><p>bash圣经中的第一个代码示例如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>trim_string<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1># Usage: trim_string &#34;   example   string    &#34;</span>
</span></span><span class=line><span class=cl>    : <span class=s2>&#34;</span><span class=si>${</span><span class=nv>1</span><span class=p>#</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>1</span><span class=p>%%[![:</span><span class=nv>space</span><span class=p>:]]*</span><span class=si>}</span><span class=s2>&#34;</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    : <span class=s2>&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>%</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>##*[![:</span><span class=nv>space</span><span class=p>:]]</span><span class=si>}</span><span class=s2>&#34;</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>printf</span> <span class=s1>&#39;%s\n&#39;</span> <span class=s2>&#34;</span><span class=nv>$_</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>好家伙，一大堆的符号，但细看之下除了 <code>:</code> 与 <code>$_</code>，其他的都是对字符串进行操作<br><code>:</code> 表示的是不输出，将指令执行的结果不输出，存起来和<code>&</code>有点类似，不过它是完全不输出（stderr我不知道会不会输出），
而 <code>&</code> 还是会输出命令完成之类的<br>另外，<code>&</code> 准确来说是放到后台执行，而 <code>:</code> 就是直接执行<br><code>$_</code> 和其他脚本语言（ python 之类的）类似，表示上一个指令执行的结果<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup><br>然后通过这两个东西就可以写出一些令人费解的代码，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Ծ‸Ծ<span class=o>(){</span>
</span></span><span class=line><span class=cl>    sleep 0.1
</span></span><span class=line><span class=cl>    <span class=nb>printf</span> <span class=s1>&#39;\e[15D&#39;</span>
</span></span><span class=line><span class=cl>    <span class=nb>printf</span> <span class=s2>&#34;\e[38;5;</span><span class=nv>$2</span><span class=s2>m&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>printf</span> <span class=nv>$1</span>
</span></span><span class=line><span class=cl>    : <span class=s2>&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>:</span><span class=nv>0</span><span class=p>-1:</span><span class=nv>1</span><span class=si>}</span><span class=s2>&#34;&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>:</span><span class=nv>0</span><span class=p>:</span><span class=nv>14</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>[[</span> <span class=nv>$2</span> -eq <span class=m>256</span> <span class=o>]]</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> Ծ‸Ծ <span class=nv>$_</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> Ծ‸Ծ <span class=nv>$_</span> $<span class=o>[</span><span class=nv>$2</span> + 1<span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=k>fi</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;\e[?25l&#39;</span>
</span></span><span class=line><span class=cl>: <span class=nb>echo</span> <span class=k>$(</span><span class=nb>echo</span> <span class=s2>&#34;4KLIDYUWQLRJNA7CS2COFFUF4KLINYUWQ7RJNCHCS2D6FFUG4KLILYUWQTRJNA7CS2BOFFUBBI======&#34;</span> <span class=p>|</span> base32 -d<span class=k>)</span>
</span></span><span class=line><span class=cl>Ծ‸Ծ <span class=nv>$_</span> <span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><p>实际上也比较好懂，就是类似于 <code>\e[?25l</code> 有些令人迷惑，这些是终端控制符.</p><h3 id=终端控制符>终端控制符</h3><p>终端控制符与 shell 无关，能否显示与所使用的终端.<br>大部分终端控制符在 bash 中的转义字符如下:</p><div class=table-wrapper><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>\e[38;5;&lt;0-255>m</td><td>设置文字颜色，256色</td></tr><tr><td>\e[48;5;&lt;0-255>m</td><td>设置背景色，256色</td></tr><tr><td>\e[38;2;[R];[G];[B]m</td><td>设置文字颜色，RGB</td></tr><tr><td>\e[48;2;[R];[G];[B]m</td><td>设置背景颜色，RGB</td></tr><tr><td>\e[m</td><td>恢复默认的颜色</td></tr><tr><td>\e[1m</td><td>加粗</td></tr><tr><td>\e[2m</td><td>亮度减半</td></tr><tr><td>\e[3m</td><td>斜体</td></tr><tr><td>\e[4m</td><td>带下划线</td></tr><tr><td>\e[5m</td><td>Blinking 看起来就是加粗，我不清楚，翻译是闪烁</td></tr><tr><td>\e[7m</td><td>背景变白 (高亮)</td></tr><tr><td>\e[8m</td><td>隐形，所有输出都会隐形！</td></tr><tr><td>\e[9m</td><td>带删除线</td></tr><tr><td>\e[[y];[x]H</td><td>将光标移动到指定行列，缺省为当前值</td></tr><tr><td>\e[H</td><td>将光标移动到 (0，0)</td></tr><tr><td>\e[xA</td><td>将光标上移 x 行，缺省为1</td></tr><tr><td>\e[xB</td><td>将光标下移 x 行，缺省为1</td></tr><tr><td>\e[xC</td><td>将光标右移 x 行，缺省为1</td></tr><tr><td>\e[xD</td><td>将光标左移 x 行，缺省为1</td></tr><tr><td>\e[s</td><td>保存光标位置</td></tr><tr><td>\e[u</td><td>恢复光标位置</td></tr><tr><td>\e[K</td><td>将光标到行尾的所有内容擦除</td></tr><tr><td>\e[1K</td><td>擦除光标到行首的全部内容</td></tr><tr><td>\e[2K</td><td>擦除光标所在行的全部内容</td></tr><tr><td>\e[J</td><td>擦除光标所在行到屏幕底端的全部内容</td></tr><tr><td>\e[1J</td><td>擦除光标所在行到屏幕顶端的全部内容</td></tr><tr><td>\e[2J</td><td>擦除屏幕</td></tr><tr><td>\e[2J\e[H</td><td>擦除屏幕并且将光标移动到 (0，0)</td></tr><tr><td>\e7</td><td>保存光标位置</td></tr><tr><td>\e8</td><td>恢复光标位置</td></tr><tr><td>\e[6n</td><td>获取光标位置</td></tr><tr><td>\e[?25l</td><td>隐藏光标</td></tr><tr><td>\e[?25h</td><td>让光标显示出来</td></tr><tr><td>\e[?7l</td><td>开启不折行，即字符会出现在屏幕外</td></tr><tr><td>\e[?7h</td><td>开启折行，当前行放不下时会放到下一行</td></tr><tr><td>\e[[a];[b]r</td><td>限制只能在 a 行到 b 行滚动（很好玩，自己去试试）</td></tr><tr><td>\e[?1049h</td><td>保存整个屏幕的所有字符</td></tr><tr><td>\e[?1049l</td><td>恢复用上一条指令保存的东西</td></tr></tbody></table></div><div class="notice notice-tip"><p>假如使用 echo 输出，那么需要开启 -e 参数，默认不会转义字符.<br>使用 printf 输出，则不需要，默认会转义字符.<br>其他的诸如 tput 需要自行测试</p></div><h3 id=heading>!</h3><p>! 可以算是相当冷门了，但这个东西相当好玩，不妨试试以下指令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> !#
</span></span><span class=line><span class=cl><span class=nb>echo</span> !!
</span></span></code></pre></td></tr></table></div></div><p>不出所料的话，应该是这样的输出</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>what@DESKTOP-EQ0RG58:~/myblog$ echo !#
</span></span><span class=line><span class=cl>echo echo
</span></span><span class=line><span class=cl>echo
</span></span><span class=line><span class=cl>what@DESKTOP-EQ0RG58:~/myblog$ echo !!
</span></span><span class=line><span class=cl>echo echo echo
</span></span><span class=line><span class=cl>echo echo
</span></span></code></pre></td></tr></table></div></div><p>是不是很神奇，这里包含了一个冷知识，也就是<code>!</code>开头的特殊变量（我把这东西称作变量应该是可以的）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 摘抄自 https://github.com/skywind3000/awesome-cheatsheets/blob/master/languages/bash.sh</span>
</span></span><span class=line><span class=cl>!!                  <span class=c1># 上一条命令</span>
</span></span><span class=line><span class=cl>!^                  <span class=c1># 上一条命令的第一个单词</span>
</span></span><span class=line><span class=cl>!:n                 <span class=c1># 上一条命令的第n个单词</span>
</span></span><span class=line><span class=cl>!:n-$               <span class=c1># 上一条命令的第n个单词到最后一个单词</span>
</span></span><span class=line><span class=cl>!$                  <span class=c1># 上一条命令的最后一个单词</span>
</span></span><span class=line><span class=cl>!-n:$               <span class=c1># 上n条命令的最后一个单词</span>
</span></span><span class=line><span class=cl>!string             <span class=c1># 最近一条包含string的命令</span>
</span></span><span class=line><span class=cl>!^string1^string2   <span class=c1># 最近一条包含string1的命令， 快速替换string1为string2</span>
</span></span><span class=line><span class=cl>!#                  <span class=c1># 本条命令之前所有的输入内容</span>
</span></span><span class=line><span class=cl>!#:n                <span class=c1># 本条命令之前的第n个单词， 快速备份cp /etc/passwd !#:1.bak</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=转义>转义</h3><p><code>echo -e</code> 可以开启输出转义，实际上另外一种方法却也是可以奏效的，那便是 <code>echo $'内容'</code> 这样的形式<br>举个例子 <code>echo -e "\e[38;5;50m what's this"</code> 等价于 <code>echo $'\e[38;5;50m what\'s this'</code><br>输出的都是一个蓝绿色的 <code>what's it</code>，显然后者写到脚本里更令人费解</p><div class="notice notice-wraning"><p>不可以使用 $&ldquo;s&rdquo; 代替 $&rsquo;s&rsquo; ，此处单双引号不等价.</p></div><h3 id=trap>trap</h3><p><code>trap</code> 在接收到指定的信号时，就会执行指定的指令<br>首先 <code>trap -l</code> 可以看到所有信号</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>what@DESKTOP-EQ0RG58 ~/myblog&gt; trap --list-signals
</span></span><span class=line><span class=cl>HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT
</span></span><span class=line><span class=cl>CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS
</span></span></code></pre></td></tr></table></div></div><p>其中 <code>INT</code> 表示 ctrl + c 时产生的信号，也可写成 SIGINT<br>EXIT 不管怎么样，只要退出就会产生<br>那么搞事情的机会就来了，在脚本第一行加入如下指令，使用者不仅无法退出，还会在试图退出时看到"略略略":)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>trap</span> <span class=s2>&#34;echo &#39;略略略&#39;;bash </span><span class=nv>$0</span><span class=s2>&#34;</span> EXIT
</span></span></code></pre></td></tr></table></div></div><h3 id=lineno>LINENO</h3><p>这个东西十分神奇，它的值为脚本执行时，该条指令所在的行号<br>比如一个脚本的内容如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>a</span><span class=o>=</span><span class=m>123</span>
</span></span><span class=line><span class=cl><span class=nv>b</span><span class=o>=</span><span class=m>456</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$LINENO</span>
</span></span></code></pre></td></tr></table></div></div><p>不出所料输出为 3<br>另外，有趣的是，在 REPL 环境中，也就是平时使用的命令行中这个变量也是存在的</p><h2 id=实用技巧>实用技巧</h2><h3 id=快速编辑指令>快速编辑指令</h3><p>这个并不属于 bash 特有的，但也一并放在这里.</p><p>在敲指令的时候，有时候会发现忘记加 sudo 或者又是少了一个参数，但此时指令很长，按方向左键简直费时费力.<br>那有没有好办法快速跳转到行首呢？<br>当然有，按 ctrl a 就可以直接将光标放到行首， ctrl e 到行尾.<br>除此之外，还有很多快捷键可以使用，比如 ctrl 删除键 会以单词为单位删除.<br>至于其他的，实在是不太常用，可能不同的终端程序支持也不同，但这三个基本上都是支持的.</p><h3 id=目录记录>目录记录</h3><p><code>cd -</code> 是个非常厉害的指令，它的作用是退回你之前所在的目录</p><div class="notice notice-tip"><p>等价于 <code>cd $OLDPWD</code>，但对 $OLDPWD 赋值并不会影响 <code>cd -</code></p></div><p>对于 <code>cd -</code> ，只能回到上一次所在的目录，想要 bash 记录更多目录，可以使用 <code>pushd</code> 和 <code>popd</code>.</p><h3 id=快速文件操作>快速文件操作</h3><p>有时候文件位于很深层的目录，这时候想去重命名的时候就显得非常麻烦了，指令大概类似于这样:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mv content/post/abc/img/xyz.png content/post/abc/img/abc.png
</span></span></code></pre></td></tr></table></div></div><p>需要敲两遍路径，费时又费力.<br>利用 <code>cd -</code> 固然可以很快解决，但未免显得相当奇怪.<br>更好的解决办法:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mv content/post/abc/img/<span class=o>{</span>xyz,abc<span class=o>}</span>.png
</span></span></code></pre></td></tr></table></div></div><p>当然，同样的方法可以利用在复制文件等等这些操作上，非常快.</p><h3 id=强制写入>强制写入</h3><p>有时会遇到这样奇怪的情况:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>what@DESKTOP-EQ0RG58:~/myblog$ echo m &gt; test.txt
</span></span><span class=line><span class=cl>bash: test.txt: cannot overwrite existing file
</span></span></code></pre></td></tr></table></div></div><p>实际上这是因为开启了 noclobber 的缘故（默认是关闭的，但可能有些脚本开启了它）<br>我们固然可以关掉它，实际上还有一种解决方法，即使用 >|<br>它们之间唯一的区别就是你有权写入该文件的情况下， >| 一定会写入，不管设置了什么</p><h3 id=读取-read-结果>读取 read 结果</h3><p>写 bash 脚本时，read 是很常用的指令.<br>但 read 有个极大的限制&ndash;会默认按照 $IFS 分割<br>实际上非常有用的是 $REPLY 这个环境变量，它默认是上一次 read 所读取到的所有东西<br>so，你可以按照你的想法来处理它而不是单一的靠 $IFS 之类的</p><h3 id=shift>shift</h3><p>写脚本时，处理参数有时候是件麻烦事，但所幸 shift 这个时候显得非常有用.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>shift</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$@</span>
</span></span></code></pre></td></tr></table></div></div><p>写入任意一个文件中，传入任意个参数，却只能得到除了第一个参数以外的所有参数，这是因为 <code>shift</code> 将原来的 $1 移除了，而原来的 $2 就成了 $1<br>这样就可以处理完一个参数，然后 <code>shift</code> 掉，接着处理子参数， <code>shift</code> 掉&mldr;</p><div class="notice notice-tip"><p>shift 可以多次调用，每次都是移除一个参数，也可以传入一个数字，控制移除的参数个数.</p></div><h3 id=heading-1>>>></h3><p>日常使用中，很多都只是一个字符串，而有时候某个指令的参数是文件名，这种情况下该怎么办？<br>将字符串写入文件再进行操作？这样好麻烦啊，实际上不用担心，因为有 &#171;&lt;<br>拿 md5sum 来说，它接受文件名作为参数，实际上使用 <code>md5sum &lt;&lt;&lt; string</code> 即可</p><h3 id=参数终止>参数终止</h3><p>当目录下有个名为 -l 的目录时应该如何输出 -l 目录下的文件？<br>直接 <code>ls -l</code> 肯定是不行的，-l 会被当成是参数而非目标目录，那么试试如下代码呢:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>a</span><span class=o>=</span><span class=s1>&#39;-l&#39;</span>
</span></span><span class=line><span class=cl>ls <span class=nv>$a</span>
</span></span></code></pre></td></tr></table></div></div><p>事实上这种办法看起来没问题，但其实还是不行. 难道是没有办法输出 -l 目录下的文件的办法吗？<br>非也，这里有一种参数终止的方法，其实说是参数终止并不完全正确，毕竟目标目录也是参数，不深究的话也无所谓.<br>使用 <code>ls -- -l</code> 就可以输出 -l 目录下的内容了.</p><div class="notice notice-tip"><p>这个例子可能并不好，毕竟使用 <code>ls ./-l</code> 就好了. 但在其他情况下，会有用到的时候，比如目标不是一个文件.<br>&ndash; 对 echo 无效</p></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>$PWD 永远指向当前目录，但 pwd 指令并不是单纯的输出 $PWD 变量.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>$0 表示的是当前所使用的 shell 的可执行文件位置，但在 bash 中如果用 <code>readlink -f</code> 去读却会得到 <code>$PWD/bash</code>.
但在 zsh 中会指向类似于 <code>/usr/bin/zsh</code> 这样的位置，取决于所使用的操作系统。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>每个目录都有两个特殊目录 . 和 ..，这也是为什么 <code>cd ..</code> 这样的指令能工作的原因.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>在诸如 python 的脚本语言中，<code>$_</code> 实际上是上一个表达式的值&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><footer class=footer><div class=copyright><svg fill="#909090" t="1651550399147" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="3700" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style/></defs><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4.0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" p-id="3701"/><path d="M517.6 351.3c53 0 89 33.8 93 83.4.3 4.2 3.8 7.4 8 7.4h56.7c2.6.0 4.7-2.1 4.7-4.7.0-86.7-68.4-147.4-162.7-147.4C407.4 290 344 364.2 344 486.8v52.3C344 660.8 407.4 734 517.3 734c94 0 162.7-58.8 162.7-141.4.0-2.6-2.1-4.7-4.7-4.7h-56.8c-4.2.0-7.6 3.2-8 7.3-4.2 46.1-40.1 77.8-93 77.8-65.3.0-102.1-47.9-102.1-133.6v-52.6c.1-87 37-135.5 102.2-135.5z" p-id="3702"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></div></footer></article></div><aside class=widgets><section class=toc><div class=widget-title-wrapper><svg fill="#909090" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20" enable-background="new 0 0 20 20"><path d="M9.7 19.9l-9-3C.3 16.8.0 16.4.0 16V1C0 .3.7-.2 1.3.1L10 2.9 18.7.0C19.3-.2 20 .3 20 1v15c0 .4-.3.8-.7.9l-9 3C10.1 20 9.9 20 9.7 19.9zM2 15.3l8 2.7 8-2.7V2.4L10.3 5C10.1 5 9.9 5 9.7 4.9L2 2.4V15.3z"/><path d="M10 16c-.6.0-1-.4-1-1V8c0-.6.4-1 1-1s1 .4 1 1v7c0 .6-.4 1-1 1z"/></svg><span class=widget-title>目录</span></div><div class=toc-list><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#奇淫巧技>奇淫巧技</a><ul><li><a href=#模式扩展>模式扩展</a></li><li><a href=#_-与->$_ 与 :</a></li><li><a href=#终端控制符>终端控制符</a></li><li><a href=#heading>!</a></li><li><a href=#转义>转义</a></li><li><a href=#trap>trap</a></li><li><a href=#lineno>LINENO</a></li></ul></li><li><a href=#实用技巧>实用技巧</a><ul><li><a href=#快速编辑指令>快速编辑指令</a></li><li><a href=#目录记录>目录记录</a></li><li><a href=#快速文件操作>快速文件操作</a></li><li><a href=#强制写入>强制写入</a></li><li><a href=#读取-read-结果>读取 read 结果</a></li><li><a href=#shift>shift</a></li><li><a href=#heading-1>>>></a></li><li><a href=#参数终止>参数终止</a></li></ul></li></ul></nav></div></section></aside></main><script type=text/javascript src=/js/main.min.js defer></script><footer class=site-footer><div class=site-copyright><span>© 2022-2022 By nidhoggfgg</span></div></footer></body></html>