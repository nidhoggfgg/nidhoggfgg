<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><link rel=icon href=/favicon.ico><title>Shell中的奇淫巧技</title><link rel=stylesheet href=/style.min.css></head><body><header class=site-header><div class=logo><svg fill="#909090" t="1651558285715" class="icon" viewBox="0 0 1034 1024" xmlns="http://www.w3.org/2000/svg" p-id="4913" width="200" height="200"><path d="M922.757 679.722c-9.278-52.003-24.544-99.516-43.39-139.068.091-.137.182-.275.275-.408.847.258 1.696.508 2.541.773-.422-.883-.863-1.76-1.292-2.643 12.366-18.578 22.399-39.972 29.136-66.647 3.516-13.909 6.145-29.263 7.783-46.397.818-8.569 1.389-17.584 1.698-27.092.156-4.751.246-9.626.269-14.633.022-5.002-.022-10.14-.133-15.402.081-10.857-.111-21.828-.471-32.944-.359-11.116-.885-22.367-1.475-33.786-1.178-22.837-2.604-46.319-3.434-70.643-1.523-34.468-1.834-70.638-2.67-105.163-19.341 6.757-39.436 15.327-59.56 25.448-81.158 40.989-166.211 107.387-215.76 191.069-1.042 1.655-2.046 3.322-3.049 4.986-38.35-10.217-79.226-15.743-121.656-15.743-43.438.0-85.243 5.795-124.381 16.487-.939-1.447-1.869-2.891-2.834-4.33-53.276-84.088-134.112-149.982-215.583-191.043-20.062-10.118-40.164-18.696-59.515-25.452-.839 34.537-1.153 70.724-2.677 105.213-1.663 48.665-5.701 93.985-5.376 137.427-1.778 83.493 13.639 133.437 39.644 171.555-.142.303-.294.602-.437.905.139-.038.277-.075.416-.112-18.356 39.116-33.223 85.823-42.326 136.86-2.678 15.01-4.747 29.82-6.254 44.359 65.632 10.539 144.907 36.168 225.818 75.514 55.879 27.177 105.924 57.687 147.427 88.735 3.259 3.722 7.779 7.212 12.852 10.232 5.65 3.36 11.912 6.11 17.756 7.969 2.927.931 5.759 1.64 8.428 2.108 1.336.237 2.633.412 3.885.526.625.052 1.241.096 1.846.115.605.021 1.2.027 1.78.018 11.043-.218 22.754-6.308 32.935-14.805h.439c43.386-33.658 97.033-66.961 157.499-96.36 80.923-39.35 160.207-64.979 225.863-75.526-1.484-13.815-3.485-27.877-6.022-42.109zM682.665 760.403c-54.102 27.67-102.101 59.014-140.921 90.693h-.392c-9.11 7.996-19.587 13.728-29.469 13.934-.52.007-1.052.003-1.594-.017-.541-.021-1.09-.059-1.652-.109-1.121-.106-2.282-.27-3.476-.495-2.389-.442-4.923-1.108-7.54-1.985-5.229-1.75-10.831-4.338-15.887-7.5-4.539-2.842-8.584-6.126-11.5-9.63-37.133-29.222-81.911-57.936-131.909-83.515C265.93 724.746 195 700.628 136.278 690.706c1.348-13.683 3.2-27.623 5.597-41.749 7.07-41.692 18.023-80.317 31.533-113.864 11.924-1.751 24.096-2.671 36.471-2.671 143.697.0 261.084 115.913 274.521 266.783h.074c1.127 17.839 12.971 31.877 27.428 31.877 15.201.0 27.523-15.518 27.523-34.659.0-2.258-.177-4.463-.505-6.602 19.173-146.753 126.643-260.464 267.536-260.464 13.608.0 26.973 1.105 40.032 3.213 14.126 34.29 25.577 74.068 32.88 117.121 2.272 13.395 4.061 26.629 5.39 39.631-58.742 9.924-129.68 34.047-202.086 71.082z" p-id="4914"/></svg><a href=/>moefox</a></div><div id=toggle-menu><svg fill="#909090" t="1651821526565" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="1919" width="200" height="200"><path d="M128 725.333333A42.666667 42.666667.0 00170.666667 768h682.666666a42.666667 42.666667.0 100-85.333333H170.666667A42.666667 42.666667.0 00128 725.333333zM128 512a42.666667 42.666667.0 0042.666667 42.666667h682.666666a42.666667 42.666667.0 100-85.333334H170.666667A42.666667 42.666667.0 00128 512zm42.666667-256a42.666667 42.666667.0 000 85.333333h682.666666a42.666667 42.666667.0 100-85.333333H170.666667z" fill="#959ba7" p-id="1920"/></svg></div></header><aside id=sidebar><ol id=main-menu class=menu><li><a href=/archives/><svg fill="#909090" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20" enable-background="new 0 0 20 20"><path d="M13 8H7c-.6.0-1-.4-1-1s.4-1 1-1h6c.6.0 1 .4 1 1s-.4 1-1 1z"/><path d="M20 11.7l-3-10C16.8 1.3 16.4 1 16 1H4c-.4.0-.8.3-1 .7l-3 10s0 .2.0.3v6c0 .6.4 1 1 1h18c.6.0 1-.4 1-1v-6C20 11.9 20 11.8 20 11.7zM4.7 3h10.5l2.4 8H13c-.6.0-1 .4-1 1v1H8v-1c0-.6-.4-1-1-1H2.3L4.7 3zM18 17H2v-4h4v1c0 .6.4 1 1 1h6c.6.0 1-.4 1-1v-1h4v4z"/></svg><span>归档</span></a></li></ol></aside><main class="main content-page"><div class=container><article class=content><header><div class=article-title-wrapper><h1 class=article-title>Shell中的奇淫巧技</h1><div class=article-meta><div class=article-time><svg fill="#909090" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20" enable-background="new 0 0 20 20"><path d="M19 2h-3V0h-2v2H6V0H4v2H1C.4 2 0 2.4.0 3v16c0 .6.4 1 1 1h18c.6.0 1-.4 1-1V3C20 2.4 19.6 2 19 2zM18 18H2V4h16V18z"/><path d="M7.3 14.7l-2-2c-.4-.4-.4-1 0-1.4s1-.4 1.4.0L8 12.6l5.3-5.3c.4-.4 1-.4 1.4.0s.4 1 0 1.4l-6 6c-.4.4-1 .4-1.4.0z"/></svg><time>2022-05-07</time></div><div class=article-time><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20" enable-background="new 0 0 20 20" fill="#909090"><path d="M18 20H2c-.6.0-1-.4-1-1s.4-1 1-1h16c.6.0 1 .4 1 1S18.6 20 18 20z"/><path d="M7 16H3c-.6.0-1-.4-1-1v-4c0-.3.1-.5.3-.7l10-10c.4-.4 1-.4 1.4.0l4 4c.4.4.4 1 0 1.4l-10 10C7.5 15.9 7.3 16 7 16zM4 14h2.6l9-9L13 2.4l-9 9V14z"/></svg><time>2022-06-29</time></div></div></div></header><section class=article><h2 id=前言>前言</h2><p>本文所有内容均在 bash 下进行，在没有特殊说明的情况下 shell 都是指 bash。<br>一部分内容在 zsh 中会有差异 (存在差异时会指出)<br>其中尽可能是 shell 的功能，而非某一个软件包所实现的功能<br>本文的内容默认读者对 shell 已经有一定了解，诸如 <code>$?</code> 或者 <code>##</code> 这些的含义本文不会赘述。<br>对于对 shell 不太了解的读者，只希望了解一点点实用技巧，可以阅读 <a href=#实用技巧>实用技巧</a> \</p><h2 id=奇淫巧技>奇淫巧技</h2><p>记录了一些奇奇怪怪、较少使用，但很有趣指令、操作等。<br>较为实用的部分在 <a href=#实用技巧>实用技巧</a><br>好玩的指令在 <a href=#just-for-fun>just-for-fun</a></p><h3 id=_-与->$_ 与 :</h3><p>bash 圣经中的第一个代码示例如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>trim_string<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1># Usage: trim_string &#34;   example   string    &#34;</span>
</span></span><span class=line><span class=cl>    : <span class=s2>&#34;</span><span class=si>${</span><span class=nv>1</span><span class=p>#</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>1</span><span class=p>%%[![:</span><span class=nv>space</span><span class=p>:]]*</span><span class=si>}</span><span class=s2>&#34;</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    : <span class=s2>&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>%</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>##*[![:</span><span class=nv>space</span><span class=p>:]]</span><span class=si>}</span><span class=s2>&#34;</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>printf</span> <span class=s1>&#39;%s\n&#39;</span> <span class=s2>&#34;</span><span class=nv>$_</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>对于字符串的操作比较基础，也有许多文档了，关注点在 <code>:</code> 和 <code>$_</code> 上。<br><code>:</code> 除了扩展后面的那一堆和重定向外，不会执行其他操作<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，这里的重定向包括输出到 stdout，并且不会输出。<br><code>$_</code> 和其他脚本语言 (python 之类的) 类似，表示上一个指令执行的结果<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup><br>通过这些就可以写一些有趣的代码:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Ծ‸Ծ<span class=o>(){</span>
</span></span><span class=line><span class=cl>    sleep 0.1
</span></span><span class=line><span class=cl>    <span class=nb>printf</span> <span class=s1>&#39;\e[15D&#39;</span>
</span></span><span class=line><span class=cl>    <span class=nb>printf</span> <span class=s2>&#34;\e[38;5;</span><span class=nv>$2</span><span class=s2>m&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>printf</span> <span class=nv>$1</span>
</span></span><span class=line><span class=cl>    : <span class=s2>&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>:</span><span class=nv>0</span><span class=p>-1:</span><span class=nv>1</span><span class=si>}</span><span class=s2>&#34;&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>:</span><span class=nv>0</span><span class=p>:</span><span class=nv>14</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>[[</span> <span class=nv>$2</span> -eq <span class=m>256</span> <span class=o>]]</span>
</span></span><span class=line><span class=cl>    <span class=k>then</span> Ծ‸Ծ <span class=nv>$_</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> Ծ‸Ծ <span class=nv>$_</span> $<span class=o>[</span><span class=nv>$2</span> + 1<span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=k>fi</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;\e[?25l&#39;</span>
</span></span><span class=line><span class=cl>: <span class=nb>echo</span> <span class=k>$(</span><span class=nb>echo</span> <span class=s2>&#34;4paB4paC4paD4paE4paF4paG4paH4paI4paH4paG4paF4paE4paD4paC4paBCg==&#34;</span> <span class=p>|</span> base64 -d<span class=k>)</span>
</span></span><span class=line><span class=cl>Ծ‸Ծ <span class=nv>$_</span> <span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><p>这段程序在 zsh 中不能正确运行。<br>其中诸如 <code>\e[?25l</code> 是终端控制符，可以在下文找到说明。</p><h3 id=模式扩展>模式扩展</h3><p>不使用 <code>pwd</code> 该如何获取当前所在目录呢，方法很多</p><ol><li>使用 <code>$PWD</code> 变量<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li><li>使用 <code>dirname $(readlink -f $0)</code> 这样的神奇的指令<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></li><li>使用 <code>readlink -f .</code> 等等<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></li></ol><p>但显得更加 &ldquo;奇淫巧技&rdquo; 的是 <code>echo ~+</code><br>实际上这是 shell 的模式扩展 (globbing)，<code>~+</code> 默认扩展成当前目录。<br>类似例子还有很多，比如 <code>~username</code> 扩展成 username 用户的主目录。为空则默认为当前用户，这就是为什么 <code>~</code> 表示当前用户的主目录了。<br>而众所周知 <code>*</code> 可以匹配除了点以外的任意字符多次，实际上开启 <code>dotglob</code> 后点也可以匹配到，比如:
目录如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>a
</span></span><span class=line><span class=cl>├── test1
</span></span><span class=line><span class=cl>│   ├── test3.txt
</span></span><span class=line><span class=cl>│   └── test4.txt
</span></span><span class=line><span class=cl>├── test2
</span></span><span class=line><span class=cl>│   ├── test5.txt
</span></span><span class=line><span class=cl>│   └── test6.txt
</span></span><span class=line><span class=cl>├── .what
</span></span><span class=line><span class=cl>└── .why
</span></span><span class=line><span class=cl>    ├── .emmm
</span></span><span class=line><span class=cl>    └── emmm
</span></span></code></pre></td></tr></table></div></div><p>在 <code>a</code> 目录下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ls *
</span></span><span class=line><span class=cl>test1:
</span></span><span class=line><span class=cl>test3.txt  test4.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>test2:
</span></span><span class=line><span class=cl>test5.txt  test6.txt
</span></span><span class=line><span class=cl>$ shopt -s dotglob
</span></span><span class=line><span class=cl>$ ls *
</span></span><span class=line><span class=cl>.what
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>test1:
</span></span><span class=line><span class=cl>test3.txt  test4.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>test2:
</span></span><span class=line><span class=cl>test5.txt  test6.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.why:
</span></span><span class=line><span class=cl>emmm
</span></span></code></pre></td></tr></table></div></div><p><code>{} []</code> 这些东西可以匹配字符，实际上开启了 <code>extglob</code> 之后还可以设置匹配的次数</p><p>更多的内容可以在 google 上找到，太多太长了，此处仅是抛砖引玉。</p><div class="notice notice-tip"><p>上面的输出可能和一般的 <code>ls</code> 指令的输出有点不太像，此处想表达的是扩展先于指令执行<br>在此处 <code>ls *</code> 会首先扩展成 <code>ls test1 test2</code> 和 <code>ls .what test1 test2 .why</code><br>即实际上输出的是多个目录下的文件。<br>值得注意的是，在 history 中仍然为 <code>ls *</code></p></div><h3 id=终端控制符>终端控制符</h3><p>终端控制符与 shell 无关，能否显示与所使用的终端。<br>大部分常用的终端控制符在 bash 中的转义字符如下:</p><div class=table-wrapper><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>\e[38;5;&lt;0-255>m</td><td>设置文字颜色，256色</td></tr><tr><td>\e[48;5;&lt;0-255>m</td><td>设置背景色，256色</td></tr><tr><td>\e[38;2;[R];[G];[B]m</td><td>设置文字颜色，RGB</td></tr><tr><td>\e[48;2;[R];[G];[B]m</td><td>设置背景颜色，RGB</td></tr><tr><td>\e[m</td><td>恢复默认的颜色</td></tr><tr><td>\e[1m</td><td>加粗</td></tr><tr><td>\e[2m</td><td>亮度减半</td></tr><tr><td>\e[3m</td><td>斜体</td></tr><tr><td>\e[4m</td><td>带下划线</td></tr><tr><td>\e[5m</td><td>Blinking 看起来就是加粗，我不清楚，翻译是闪烁</td></tr><tr><td>\e[7m</td><td>背景变白 (高亮)</td></tr><tr><td>\e[8m</td><td>隐形，所有输出都会隐形！</td></tr><tr><td>\e[9m</td><td>带删除线</td></tr><tr><td>\e[[y];[x]H</td><td>将光标移动到指定行列，缺省为当前值</td></tr><tr><td>\e[H</td><td>将光标移动到 (0，0)</td></tr><tr><td>\e[xA</td><td>将光标上移 x 行，缺省为1</td></tr><tr><td>\e[xB</td><td>将光标下移 x 行，缺省为1</td></tr><tr><td>\e[xC</td><td>将光标右移 x 行，缺省为1</td></tr><tr><td>\e[xD</td><td>将光标左移 x 行，缺省为1</td></tr><tr><td>\e[s</td><td>保存光标位置</td></tr><tr><td>\e[u</td><td>恢复光标位置</td></tr><tr><td>\e[K</td><td>将光标到行尾的所有内容擦除</td></tr><tr><td>\e[1K</td><td>擦除光标到行首的全部内容</td></tr><tr><td>\e[2K</td><td>擦除光标所在行的全部内容</td></tr><tr><td>\e[J</td><td>擦除光标所在行到屏幕底端的全部内容</td></tr><tr><td>\e[1J</td><td>擦除光标所在行到屏幕顶端的全部内容</td></tr><tr><td>\e[2J</td><td>擦除屏幕</td></tr><tr><td>\e7</td><td>保存光标位置</td></tr><tr><td>\e8</td><td>恢复光标位置</td></tr><tr><td>\e[6n</td><td>获取光标位置</td></tr><tr><td>\e[?25l</td><td>隐藏光标</td></tr><tr><td>\e[?25h</td><td>让光标显示出来</td></tr><tr><td>\e[?7l</td><td>开启不折行，即字符会出现在屏幕外</td></tr><tr><td>\e[?7h</td><td>开启折行，当前行放不下时会放到下一行</td></tr><tr><td>\e[[a];[b]r</td><td>限制只能在 a 行到 b 行滚动（很好玩，自己去试试）</td></tr><tr><td>\e[?1049h</td><td>保存整个屏幕的所有字符</td></tr><tr><td>\e[?1049l</td><td>恢复用上一条指令保存的东西</td></tr></tbody></table></div><p>这些转义字符可以任意组合使用，比如 <code>\e[38;2;100;0;100m\e[3mfuck\e[m</code> 则是一个紫色的斜体 fuck</p><div class="notice notice-tip"><p>假如使用 echo 输出，那么需要开启 -e 参数或者下文描述的奇淫巧技，默认不会转义字符。<br>使用 printf 输出，则不需要任何参数，默认会转义字符。<br>其他的诸如 tput 自行测试</p></div><h3 id=heading>!</h3><p><code>!</code> 这个东西相当有趣，不妨试试以下指令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> !#
</span></span><span class=line><span class=cl><span class=nb>echo</span> !!
</span></span></code></pre></td></tr></table></div></div><p>不出所料的话，应该是这样的输出</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ echo !#
</span></span><span class=line><span class=cl>echo echo
</span></span><span class=line><span class=cl>echo
</span></span><span class=line><span class=cl>$ echo !!
</span></span><span class=line><span class=cl>echo echo echo
</span></span><span class=line><span class=cl>echo echo
</span></span></code></pre></td></tr></table></div></div><p>实际上可用的 <code>!</code> 操作如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 摘抄自 https://github.com/skywind3000/awesome-cheatsheets/blob/master/languages/bash.sh</span>
</span></span><span class=line><span class=cl>!!                  <span class=c1># 上一条命令</span>
</span></span><span class=line><span class=cl>!^                  <span class=c1># 上一条命令的第一个单词</span>
</span></span><span class=line><span class=cl>!:n                 <span class=c1># 上一条命令的第n个单词</span>
</span></span><span class=line><span class=cl>!:n-$               <span class=c1># 上一条命令的第n个单词到最后一个单词</span>
</span></span><span class=line><span class=cl>!$                  <span class=c1># 上一条命令的最后一个单词</span>
</span></span><span class=line><span class=cl>!-n:$               <span class=c1># 上n条命令的最后一个单词</span>
</span></span><span class=line><span class=cl>!string             <span class=c1># 最近一条包含string的命令</span>
</span></span><span class=line><span class=cl>!^string1^string2   <span class=c1># 最近一条包含string1的命令， 快速替换string1为string2</span>
</span></span><span class=line><span class=cl>!#                  <span class=c1># 本条命令之前所有的输入内容</span>
</span></span><span class=line><span class=cl>!#:n                <span class=c1># 本条命令之前的第n个单词， 快速备份cp /etc/passwd !#:1.bak</span>
</span></span></code></pre></td></tr></table></div></div><p>类似于宏，在执行之前就会替换掉，所以执行 <code>echo !#</code> 实际执行的是 <code>echo echo</code> 并且在 history 中也是如此。</p><div class="notice notice-warning"><p>另外不能用于脚本文件中，不能写<del>装逼</del>带有魔法的代码了。</p></div><h3 id=转义>转义</h3><p><code>echo -e</code> 可以开启输出转义，实际上另外一种方法却也是可以奏效的，那便是 <code>echo $'内容'</code> 这样的形式<br>举个例子 <code>echo $'\e[38;5;50m what\'s this'</code> 等价于 <code>echo -e "\e[38;5;50m what's this"</code><br>输出的都是一个蓝绿色的 <code>what's this</code></p><div class="notice notice-warning"><p>不可以使用 $&ldquo;s&rdquo; 代替 $&rsquo;s&rsquo; ，此处单双引号不等价.</p></div><h3 id=trap>trap</h3><p><code>trap</code> 在接收到指定的信号时，就会执行指定的指令<br>首先 <code>trap -l</code> 可以看到所有信号，或者 <code>trap --list-signals</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ trap --list-signals
</span></span><span class=line><span class=cl>HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT
</span></span><span class=line><span class=cl>CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS
</span></span></code></pre></td></tr></table></div></div><p>其中 INT 表示 ctrl + c 时产生的信号，也可写成 SIGINT<br>EXIT 不管怎么样，只要退出就会产生<br>那么搞事情的机会就来了，在脚本第一行加入如下指令，使用者不仅无法退出，还会在试图退出时看到 &ldquo;略略略&rdquo; :)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>trap</span> <span class=s2>&#34;echo &#39;略略略&#39;;bash </span><span class=nv>$0</span><span class=s2>&#34;</span> EXIT
</span></span></code></pre></td></tr></table></div></div><p>不影响正常运行，只在退出时输出并用 bash 执行当前文件，即重启脚本。</p><h3 id=lineno>LINENO</h3><p>这个变量非常有趣，它的值为脚本执行时，该条指令所在的行号<br>比如一个脚本的内容如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>a</span><span class=o>=</span><span class=m>123</span>
</span></span><span class=line><span class=cl><span class=nv>b</span><span class=o>=</span><span class=m>456</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$LINENO</span>
</span></span></code></pre></td></tr></table></div></div><p>输出为 3<br>另外，有趣的是，在平时使用的命令行中这个变量也是存在的</p><h3 id=创建文件>创建文件</h3><p>相比于 <code>touch</code> 用于创建一个空文件，<code>: ></code><sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> 可能显得更加牛逼一些。<br>更加丧心病狂的做法可能是 <code>: made_by_❤ > somefile</code> 去创建空的 <code>somefile</code><br>或者更更更加丧心病狂使用类似于 <code>: rm -rf / > somefile</code> 这样的指令，让人误以为是恶意指令。</p><div class="notice notice-warning"><p>此处的 <code>made_by_❤</code> 和 <code>rm -rf /</code> 并 <strong>不会</strong> 执行也 <strong>不会</strong> 写入到文件中，原因见 <a href=#_-%E4%B8%8E->$_ 和 :</a><br>但请不要使用到可 globbing 的符号和重定向 (最简单的做法就是不用英文符号)</p></div><h3 id=强制写入>强制写入</h3><p>有时会遇到这样奇怪的情况:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ echo m &gt; test.txt
</span></span><span class=line><span class=cl>bash: test.txt: cannot overwrite existing file
</span></span></code></pre></td></tr></table></div></div><p>实际上这是因为开启了 noclobber 的缘故 (默认是关闭的，但可能有些脚本开启了它)<br>我们固然可以关掉它，实际上还有一种解决方法，即使用 >|<br>它们之间唯一的区别就是你有权写入该文件的情况下， >| 一定会写入，不管设置了什么<br>当然，重新开一个 shell 会更快解决问题，并且不用知道为什么，但多少有些无趣</p><h2 id=实用技巧>实用技巧</h2><h3 id=快速编辑指令>快速编辑指令</h3><p>这个并不属于 bash 特有的，但也一并放在这里 (其实应该是终端提供的功能，但就算是在纯的 tty 也能用)。<br>在敲指令的时候，有时候会发现忘记加 sudo 或者又是少了一个参数，但此时指令很长，按方向左键简直费时费力。<br>那有没有好办法快速跳转到行首呢？<br>当然有，按 ctrl + a 就可以直接将光标放到行首， ctrl + e 到行尾。<br>除此之外，还有很多快捷键可以使用，这里给出一些常用的:</p><p>ctrl + w 删除前一个单词，vim 中可用<br>ctrl + u 删除整行，vim 中可用</p><h3 id=目录记录>目录记录</h3><p><code>cd -</code> 是个非常厉害的指令，它的作用是退回你之前所在的目录</p><div class="notice notice-tip"><p>等价于 <code>cd $OLDPWD</code>，但对 $OLDPWD 赋值并不会影响 <code>cd -</code></p></div><p>对于 <code>cd -</code>，只能回到上一次所在的目录，想要 bash 记录更多目录，可以使用 <code>pushd</code> 和 <code>popd</code>(那么就不是高效操作了)。</p><h3 id=快速文件操作>快速文件操作</h3><p>有时候文件位于很深层的目录，这时候想去重命名的时候就显得非常麻烦了，指令大概类似于这样:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mv content/post/abc/img/xyz.png content/post/abc/img/abc.png
</span></span></code></pre></td></tr></table></div></div><p>需要敲两遍路径，费时又费力。<br>利用 <code>cd -</code> 固然可以很快解决，一步跳进目录再一步跳出，感觉还是差点意思。<br>更好的解决办法:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mv content/post/abc/img/<span class=o>{</span>xyz,abc<span class=o>}</span>.png
</span></span></code></pre></td></tr></table></div></div><p>当然，同样的方法可以利用在复制文件，修改后缀等等这些操作上，非常好用。</p><h3 id=读取-read-结果>读取 read 结果</h3><p>写 bash 脚本时，read 是很常用的指令。<br>但 read 有个极大的限制 —— 会默认按照 <code>$IFS</code> 分割<br>实际上可以使用 $REPLY 这个变量来处理 read 结果，它默认是上一次 read 所读取到的所有东西。 <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup><br>接着就是简简单单的字符串处理了。</p><h3 id=shift>shift</h3><p>写脚本时，处理参数有时候是件麻烦事，但所幸 shift 这个时候显得非常有用.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>shift</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$@</span>
</span></span></code></pre></td></tr></table></div></div><p>写入任意一个文件中，传入任意个参数，却只能得到除了第一个参数以外的所有参数，这是因为 <code>shift</code> 将原来的 $1 移除了，而原来的 $2 就成了 $1<br>这样就可以处理完一个参数，然后 <code>shift</code> 掉，接着处理子参数，<code>shift</code> 掉&mldr;</p><div class="notice notice-tip"><p>shift 可以多次调用，每次都是移除一个参数，也可以传入一个数字，控制移除的参数个数.</p></div><h3 id=heading-1>>>></h3><p>日常使用中，很多都只是一个字符串，而有时候某个指令的参数是文件名，这种情况下该怎么办？<br>将字符串写入文件再进行操作？这样好麻烦啊。<br>实际上不用担心，因为有 &lt;&lt;&lt;<br>拿 md5sum 来说，它接受文件名作为参数，实际上使用 <code>md5sum &lt;&lt;&lt; string</code> 即可</p><div class="notice notice-tip"><p><code>echo "string" | md5sum</code> 也是一样的，还更加实用一些 (不用思考)</p></div><h3 id=参数终止>参数终止</h3><p>当目录下有个名为 -l 的目录时应该如何输出 -l 目录下的文件？<br>直接 <code>ls -l</code> 肯定是不行的，-l 会被当成是参数而非目标目录，那么试试如下代码呢:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>a</span><span class=o>=</span><span class=s1>&#39;-l&#39;</span>
</span></span><span class=line><span class=cl>ls <span class=nv>$a</span>
</span></span></code></pre></td></tr></table></div></div><p>事实上这种办法看起来没问题，但其实还是不行。<br>难道是没有办法输出 -l 目录下的文件的办法吗？<br>非也，这里有一种参数终止的方法，使用 -- 。<br>使用 <code>ls -- -l</code> 就可以输出 -l 目录下的内容了。</p><div class="notice notice-tip"><p>这个例子可能并不好，毕竟使用 <code>ls ./-l</code> 就好了。但在其他情况下，会有用到的时候，比如目标不是一个文件。<br>-- 对 echo 无效</p></div><h3 id=快速上一条指令>快速上一条指令</h3><p>使用方向键来填充上一条指令是不错的选择。<br>拥有同样效果的还有 !!，使用起来也很方便。<br>比如:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>apt install vim <span class=c1># wrong! 非 root 用户无权执行</span>
</span></span><span class=line><span class=cl>sudo !! <span class=c1># fine! 等价于 sudo apt install vim</span>
</span></span></code></pre></td></tr></table></div></div><div class="notice notice-tip"><p>在 zsh 中还有一个 r，但注意 <code>sudo r</code> 正常情况下不行，zsh 特有的。</p></div><h3 id=快速修改上一条指令>快速修改上一条指令</h3><p>在敲击命令中的过程中错误是很常见的事情，也有很多解决办法：zsh 的插件纠正， thefuck&mldr;&mldr;<br>但其实无需其他的任何的程序，bash 中已经提供了一个 <code>^</code><br>比如，想要敲击 <code>sudo apt install vim</code> 但是敲成了 <code>sudi apt install vim</code>，bash 很直接地告诉我们指令错了。<br>那么此时只须执行 <code>^i^o</code>(意思是将第一个 i 替换为 o) 即可直接执行正确的指令:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sudi pacman -Syyu
</span></span><span class=line><span class=cl>bash: sudi：未找到命令
</span></span><span class=line><span class=cl>$ ^i^o
</span></span><span class=line><span class=cl>sudo pacman -Syyu
</span></span><span class=line><span class=cl>[sudo] nidhoggfgg 的密码：
</span></span></code></pre></td></tr></table></div></div><h3 id=快速粘贴参数>快速粘贴参数</h3><p>对于如下例子:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ls projects/fpig/fp/vm/src/
</span></span><span class=line><span class=cl>chunk.rs  lib.rs  object.rs  op.rs
</span></span><span class=line><span class=cl>$ cd projects/fpig/fp/vm/src/
</span></span></code></pre></td></tr></table></div></div><p>其中需要两次敲击 <code>projects/fpig/fp/vm/src</code>，这需要敲很多键。<br>当然，可以利用前文所述的快速编辑，但仍然显得很麻烦。<br>实际上第二个路径不需要敲，只需要敲完 <code>cd</code> 之后按下 <code>Alt + .</code> 就可以自动粘贴上一条指令的参数！<br>也就是:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ls projects/fpig/fp/vm/src/
</span></span><span class=line><span class=cl>chunk.rs  lib.rs  object.rs  op.rs
</span></span><span class=line><span class=cl>$ cd &lt;Alt + .&gt;
</span></span></code></pre></td></tr></table></div></div><p>就可以直接自动补全了。</p><div class="notice notice-tip"><p>这个例子或许不是很恰当，毕竟可以使用上述的小技巧 <code>^ls^cd</code> 一步完成</p></div><h3 id=cdpath>CDPATH</h3><p><code>CDPATH</code> 是一个特殊的环境变量，类似于 <code>PATH</code>，比如:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$echo $CDPATH
</span></span><span class=line><span class=cl>:/home/nidhoggfgg/projects
</span></span><span class=line><span class=cl>$cd fpig
</span></span><span class=line><span class=cl>$pwd
</span></span><span class=line><span class=cl>/home/nidhoggfgg/projects/fpig
</span></span></code></pre></td></tr></table></div></div><p>第二步使用 <code>cd fpig</code> 就直接跳入了 <code>/home/nidhoggfgg/projects/fpig</code>，可以极大的节省时间。<br>建议填入常用的目录然后写入 ~/.zshrc 或者 ~/.bashrc</p><h3 id=清除屏幕>清除屏幕</h3><p><code>clear</code> 是个不错的选择，但或许用快捷键 ctrl + l 会更快</p><h3 id=不匹配文件>不匹配文件</h3><p>有时候操作文件，跳过一些文件而不是选择一些文件可能更好，比如:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>rm !<span class=o>(</span>*.md<span class=p>|</span>*.jpeg<span class=p>|</span>*.jpg<span class=p>|</span>*.png<span class=p>|</span>abc.txt<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>删除所有除了以 md, jpeg, jpg, png 结尾以及 abc.txt 以外的所有文件。<br>在 zsh 中无效，在 bash 中需要开启 <code>extglob</code>，即需要 <code>shopt -s extglob</code></p><h3 id=不保留历史记录>不保留历史记录</h3><p>有时候会执行一些参数上带有隐私内容的指令，比如一些远程登陆等等，这时候并不想把这条指令留在历史记录里。<br>当然，写入文件里执行是不会被记录的，但未免太麻烦了。<br>难道没有其他办法吗？其实这也是有办法的。<br>最为简单的办法就是在指令前加一个空格，就可以做到了，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[space]echo &#34;LOL&#34;
</span></span></code></pre></td></tr></table></div></div><p>其中的 <code>[space]</code> 表示一个空格。</p><p>还有很多通过操纵 history 来实现同样或者更强的效果的，用处不大此处不再赘述。</p><h3 id=cheatsheet>cheatsheet</h3><p>忘记命令的参数用法的事常有，但往往 <code>--help</code> 一大堆的输出里不能很快地找到需要的，更别说 <code>man</code> 动辄几十上百页的说明了。<br>其实有一种更加简单的方式就是使用 cheatsheet 了。<br>对于最轻量的使用方法，不用安装程序的就是使用 <code>curl</code> 了，比如:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl cheat.sh/ls
</span></span></code></pre></td></tr></table></div></div><p>将以下几行添加到 <code>~/.zshrc</code> 或者 <code>~/.bashrc</code> 会很有用:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>how<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    curl cheat.sh/<span class=nv>$1</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>之后就可以使用 <code>how</code> 来查询不知道的指令的使用方法了。</p><h3 id=查看系统及硬件信息>查看系统及硬件信息</h3><p><code>lscpu</code>, <code>free</code>, <code>lsblk</code> 分别可以查看 cpu，内存，硬盘信息，他们的使用方法可以使用上述的 <code>how</code> 函数查询。<br><code>/etc/issue</code> 里存储了 linux 发行版的名字，比如 <code>Manjaro Linux</code></p><h2 id=just-for-fun>just for fun</h2><p>这里收集了一些好玩的，只是非常非常非常小的一部分，很多惊艳到我的都没记录下来。<br>有一部分指令可能有一定的实用价值。</p><h3 id=表情>表情</h3><p>输出所有的笑脸 <a href=https://www.commandlinefu.com/commands/by/ichbins>author: ichbins</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s2>&#34;</span><span class=k>$(</span>awk <span class=s1>&#39;BEGIN{c=127;while(c++&lt;191){printf(&#34;\xf0\x9f\x98\\%s&#34;,sprintf(&#34;%o&#34;,c));}}&#39;</span><span class=k>)</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>原理是输出 &ldquo;\xf0\x9f\x98\x80&rdquo; (😀) 到 &ldquo;\xf0\x9f\x98\xbe&rdquo; (😾)。并用 awk 简化了一下，写成单行。<br>这也是不全的，比如在 U+1F910 到 U+1F917 也是笑脸，其他的还有。<br>同样的，还可以输出小动物 (改成了 16 进制，更加合理了!)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s2>&#34;</span><span class=k>$(</span>awk <span class=s1>&#39;BEGIN{c=127;while(c++&lt;174){printf(&#34;\xf0\x9f\xa6\\x%s&#34;,sprintf(&#34;%x&#34;,c));}}&#39;</span><span class=k>)</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>或者伏羲六十四卦</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s2>&#34;</span><span class=k>$(</span>awk <span class=s1>&#39;BEGIN{c=133;while(c++&lt;191){printf(&#34;\xf0\x9d\x8c\\x%s&#34;,sprintf(&#34;%x&#34;,c));}}&#39;</span><span class=k>)</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>printf</span> <span class=s2>&#34;</span><span class=k>$(</span>awk <span class=s1>&#39;BEGIN{c=127;while(c++&lt;150){printf(&#34;\xf0\x9d\x8d\\x%s&#34;,sprintf(&#34;%x&#34;,c));}}&#39;</span><span class=k>)</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>由于并不是连续的，为了简单就分成两条指令了。<br>还可以输出一整套象形文字等等，翻 unicode 表就好了。</p><h3 id=进度条>进度条</h3><p>彩色进度条 <a href=https://blog.nidhoggfgg.fun>author: me</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Ծ‸Ծ<span class=o>(){</span> sleep 0.1<span class=p>;</span><span class=nb>printf</span> <span class=s1>&#39;\e[15D&#39;</span><span class=p>;</span><span class=nb>printf</span> <span class=s2>&#34;\e[38;5;</span><span class=nv>$2</span><span class=s2>m&#34;</span><span class=p>;</span><span class=nb>printf</span> <span class=nv>$1</span><span class=p>;</span>: <span class=s2>&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>:</span><span class=nv>0</span><span class=p>-1:</span><span class=nv>1</span><span class=si>}</span><span class=s2>&#34;&#34;</span><span class=si>${</span><span class=nv>_</span><span class=p>:</span><span class=nv>0</span><span class=p>:</span><span class=nv>14</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>;</span> <span class=k>if</span> <span class=o>[[</span> <span class=nv>$2</span> -eq <span class=m>256</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then</span> Ծ‸Ծ <span class=nv>$_</span> 1<span class=p>;</span> <span class=k>else</span> Ծ‸Ծ <span class=nv>$_</span> $<span class=o>[</span><span class=nv>$2</span> + 1<span class=o>]</span><span class=p>;</span> <span class=k>fi</span><span class=p>;</span> <span class=o>}</span><span class=p>;</span> <span class=nb>printf</span> <span class=s1>&#39;\e[?25l&#39;</span><span class=p>;</span> : <span class=nb>echo</span>  <span class=k>$(</span><span class=nb>echo</span> <span class=s2>&#34;4KLIDYUWQLRJNA7CS2COFFUF4KLINYUWQ7RJNCHCS2D6FFUG4KLILYUWQTRJNA7CS2BOFFUBBI======&#34;</span> <span class=p>|</span> base32 -d<span class=k>)</span><span class=p>;</span>Ծ‸Ծ <span class=nv>$_</span> <span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><p>高中时无聊写的，逻辑上简单，但混淆上还是有一点功夫的。需要知道 <a href=#_-与->$_ 和 :</a></p><h3 id=时钟>时钟</h3><p>右上角时钟 <a href=https://www.commandlinefu.com/commands/by/glaudiston>author: glaudiston</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=k>while</span> sleep 1<span class=p>;</span><span class=k>do</span> tput sc<span class=p>;</span>tput cup <span class=m>0</span> <span class=k>$(($(</span>tput cols<span class=k>)</span><span class=o>-</span><span class=m>29</span><span class=k>))</span><span class=p>;</span>date<span class=p>;</span>tput rc<span class=p>;</span><span class=k>done</span> <span class=p>&amp;</span>
</span></span></code></pre></td></tr></table></div></div><p>这个相当厉害了，在终端的右上角挂一个时钟，具体的什么样的，一试便知。<br>同样的，还可以发挥想象挂些其他的东西上去！<br>但因为 UTC 的缘故，长度有变，更好的指令如下 (将原作者的指令中的 29 改成 36):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=k>while</span> sleep 1<span class=p>;</span><span class=k>do</span> tput sc<span class=p>;</span>tput cup <span class=m>0</span> <span class=k>$(($(</span>tput cols<span class=k>)</span><span class=o>-</span><span class=m>36</span><span class=k>))</span><span class=p>;</span>date<span class=p>;</span>tput rc<span class=p>;</span><span class=k>done</span> <span class=p>&amp;</span>
</span></span></code></pre></td></tr></table></div></div><p>但不过值得注意的是，由于反复 <code>sleep</code> 会导致系统不断分配新的 <code>pid</code>。在一般情况下，<code>pid</code> 会一直自增，这会导致后续进程的 <code>pid</code> 非常大。</p><h3 id=查看目录磁盘使用量>查看目录磁盘使用量</h3><p>可以很方便地在命令行下查看磁盘使用量 <a href=https://www.commandlinefu.com/commands/by/x3mboy>author: x3mboy</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>du --max-depth<span class=o>=</span><span class=m>1</span> -h . <span class=p>|</span> sort -rh
</span></span></code></pre></td></tr></table></div></div><p>用 <code>du</code> 查看，<code>sort</code> 排序</p><p><em>和原作者不同，我添加了 <code>-r</code> 参数表示逆序 (从大到小)</em></p><h3 id=以表的形式查看文件>以表的形式查看文件</h3><p><img src=imgs/5520cb.png alt=table></p><p>将长字符串分割并添加头部 <a href=https://www.commandlinefu.com/commands/by/wuseman1>author: wuseman1</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>column -s: -t -n . -N USERNAME,PASS,UID,GID,NAME,HOMEDIR,SHELL -T NAME /etc/passwd<span class=p>|</span>sed <span class=s2>&#34;1,2 i </span><span class=k>$(</span><span class=nb>printf</span> %80s<span class=p>|</span>tr <span class=s1>&#39; &#39;</span> <span class=s1>&#39;=&#39;</span><span class=k>)</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>如果只想阅读前几行或者前一部分，可以利用 <code>head -n x</code></p><p>更多的，还可以阅读 csv 文件，比如:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>column -s, -t xxx.csv <span class=p>|</span> head -n <span class=m>5</span> <span class=p>|</span> tail -n +1 <span class=p>|</span>sed <span class=s2>&#34;1,2 i </span><span class=k>$(</span><span class=nb>printf</span> %80s<span class=p>|</span>tr <span class=s1>&#39; &#39;</span> <span class=s1>&#39;=&#39;</span><span class=k>)</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>其中的 <code>tail -n +1</code> 是必须的，<code>head -n 5</code> 则是为了查看前 4 行 (标题也算一行)，<code>-s,</code> 是因为 csv 文件中的字段按照 <code>,</code> 分割</p><h3 id=摄像头>摄像头</h3><p>在 linux 中使用摄像头其实不是一件难事，最简单的办法只需要:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mplayer tv://
</span></span></code></pre></td></tr></table></div></div><p>或者更多的，安装了 <code>libcaca</code> 的话，还可以用 caca 像素画:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mplayer tv:// -vo caca
</span></span></code></pre></td></tr></table></div></div><h3 id=使-bash-崩溃>使 bash 崩溃</h3><p>注意，我的用词是崩溃不是错误！<br>使用以下指令，可以直接使 bash 崩溃:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>enable</span> -f /usr/lib/libpng.so png_create_read
</span></span></code></pre></td></tr></table></div></div><p>看起来完全人畜无害<br>这不算什么，但是假如更加恶毒一点:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;enable -f /usr/lib/libpng.so png_create_read&#34;</span> &gt;&gt; ~/.bashrc
</span></span></code></pre></td></tr></table></div></div><p>那么用户启动 bash 的时候就会崩溃！对于新手，他将毫无头绪也不知道怎么解决问题！:)</p><h3 id=curltelnetssh-合集>curl/telnet/ssh 合集</h3><p>一般都是一些没事干的家伙，又有闲着的服务器 (我也) 跑了一些服务专供好玩</p><p><a href=https://github.com/chubin/awesome-console-services>awesome-console-services</a> 收集了一大堆类似的，下面节选了一部分</p><h4 id=看天气>看天气</h4><p>这个确实很惊艳了，主要是界面做得很好</p><p><img src=imgs/96b0faf.png alt=wttr.in></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl wttr.in <span class=c1># 会自动获取地理位置</span>
</span></span><span class=line><span class=cl>curl wttr.in/haikou <span class=c1># 指定城市，比如 haikou</span>
</span></span><span class=line><span class=cl>curl v2.wttr.in <span class=c1># v2 版本，很像手机里的天气应用</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=看动画>看动画</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>telnet towel.blinkenlights.nl <span class=c1># 星球大战</span>
</span></span><span class=line><span class=cl>telnet rya.nc <span class=m>1987</span> <span class=c1># 你被骗了</span>
</span></span><span class=line><span class=cl>curl https://poptart.spinda.net <span class=c1># 彩虹猫</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=imgs/8b1eb3.png alt=nyancat></p><p>在一般常用的 linux 发行版上可以找到一个名为 <code>nyancat</code> 的包，这个也是彩虹猫。</p><h4 id=桌面环境>桌面环境</h4><p>非常离谱了，主要是看起来不像是终端的低分辨率，以及居然有背景透明和背景模糊！</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ssh vtm@netxs.online
</span></span></code></pre></td></tr></table></div></div><p>ssh 连接之后可能会很卡，网络和服务器资源都占了点原因，可以去<a href=https://github.com/netxs-group/VTM>仓库地址</a>看看，非常之惊艳</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>这意味着类似于 <code>: echo "e"</code> 是会执行的，而 <code>: mkdir a</code> 是不会执行的。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>在诸如 python 的脚本语言中，<code>_</code> 一般上是上一个表达式的值。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><code>$PWD</code> 永远指向当前目录，但 <code>pwd</code> 指令并不是单纯的输出 <code>$PWD</code> 变量。&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><code>$0</code> 表示的是当前所使用的 shell 的可执行文件位置。在 bash 中如果用 <code>readlink -f</code> 去读却会得到 <code>$PWD/bash</code>。
但在 zsh 中会指向类似于 <code>/usr/bin/zsh</code> 这样的位置。&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>每个目录都有两个特殊目录 <code>.</code> 和 <code>..</code>，这也是为什么 <code>cd ..</code> 这样的指令能工作的原因。&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><code>: > abc.txt</code> 实际上等价于 <code>: "" > abc.txt</code> 也就是利用 <code>:</code> 执行 <code>"" > abc.txt</code>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>read 仍然受单行所限制，即 <code>cat some | {read; echo $REPLY }</code> 只能得到 some 中第一行的内容&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><footer class=footer><div class=copyright><svg fill="#909090" t="1651550399147" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="3700" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style/></defs><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4.0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" p-id="3701"/><path d="M517.6 351.3c53 0 89 33.8 93 83.4.3 4.2 3.8 7.4 8 7.4h56.7c2.6.0 4.7-2.1 4.7-4.7.0-86.7-68.4-147.4-162.7-147.4C407.4 290 344 364.2 344 486.8v52.3C344 660.8 407.4 734 517.3 734c94 0 162.7-58.8 162.7-141.4.0-2.6-2.1-4.7-4.7-4.7h-56.8c-4.2.0-7.6 3.2-8 7.3-4.2 46.1-40.1 77.8-93 77.8-65.3.0-102.1-47.9-102.1-133.6v-52.6c.1-87 37-135.5 102.2-135.5z" p-id="3702"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></div></footer></article></div><aside class=widgets><section class=toc><div class=widget-title-wrapper><svg fill="#909090" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20" enable-background="new 0 0 20 20"><path d="M9.7 19.9l-9-3C.3 16.8.0 16.4.0 16V1C0 .3.7-.2 1.3.1L10 2.9 18.7.0C19.3-.2 20 .3 20 1v15c0 .4-.3.8-.7.9l-9 3C10.1 20 9.9 20 9.7 19.9zM2 15.3l8 2.7 8-2.7V2.4L10.3 5C10.1 5 9.9 5 9.7 4.9L2 2.4V15.3z"/><path d="M10 16c-.6.0-1-.4-1-1V8c0-.6.4-1 1-1s1 .4 1 1v7c0 .6-.4 1-1 1z"/></svg><span class=widget-title>目录</span></div><div class=toc-list><nav id=TableOfContents><ol><li><a href=#前言>前言</a></li><li><a href=#奇淫巧技>奇淫巧技</a><ol><li><a href=#_-与->$_ 与 :</a></li><li><a href=#模式扩展>模式扩展</a></li><li><a href=#终端控制符>终端控制符</a></li><li><a href=#heading>!</a></li><li><a href=#转义>转义</a></li><li><a href=#trap>trap</a></li><li><a href=#lineno>LINENO</a></li><li><a href=#创建文件>创建文件</a></li><li><a href=#强制写入>强制写入</a></li></ol></li><li><a href=#实用技巧>实用技巧</a><ol><li><a href=#快速编辑指令>快速编辑指令</a></li><li><a href=#目录记录>目录记录</a></li><li><a href=#快速文件操作>快速文件操作</a></li><li><a href=#读取-read-结果>读取 read 结果</a></li><li><a href=#shift>shift</a></li><li><a href=#heading-1>>>></a></li><li><a href=#参数终止>参数终止</a></li><li><a href=#快速上一条指令>快速上一条指令</a></li><li><a href=#快速修改上一条指令>快速修改上一条指令</a></li><li><a href=#快速粘贴参数>快速粘贴参数</a></li><li><a href=#cdpath>CDPATH</a></li><li><a href=#清除屏幕>清除屏幕</a></li><li><a href=#不匹配文件>不匹配文件</a></li><li><a href=#不保留历史记录>不保留历史记录</a></li><li><a href=#cheatsheet>cheatsheet</a></li><li><a href=#查看系统及硬件信息>查看系统及硬件信息</a></li></ol></li><li><a href=#just-for-fun>just for fun</a><ol><li><a href=#表情>表情</a></li><li><a href=#进度条>进度条</a></li><li><a href=#时钟>时钟</a></li><li><a href=#查看目录磁盘使用量>查看目录磁盘使用量</a></li><li><a href=#以表的形式查看文件>以表的形式查看文件</a></li><li><a href=#摄像头>摄像头</a></li><li><a href=#使-bash-崩溃>使 bash 崩溃</a></li><li><a href=#curltelnetssh-合集>curl/telnet/ssh 合集</a><ol><li><a href=#看天气>看天气</a></li><li><a href=#看动画>看动画</a></li><li><a href=#桌面环境>桌面环境</a></li></ol></li></ol></li></ol></nav></div></section></aside></main><footer class=site-footer><div class=site-copyright><span>© 2022-2022 By nidhoggfgg</span></div></footer><script type=text/javascript src=/js/main.min.js defer></script></body></html>