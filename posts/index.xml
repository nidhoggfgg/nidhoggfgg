<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on nothing</title><link>https://blog.nidhoggfgg.fun/posts/</link><description>Recent content in Posts on nothing</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 14 Nov 2022 20:54:27 +0800</lastBuildDate><atom:link href="https://blog.nidhoggfgg.fun/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>终端输出甜甜圈</title><link>https://blog.nidhoggfgg.fun/post/1a2d7e39/</link><pubDate>Mon, 14 Nov 2022 20:54:27 +0800</pubDate><guid>https://blog.nidhoggfgg.fun/post/1a2d7e39/</guid><description>前言 这篇文章是在看了 how donut.c works 之后写的，或许这篇文章应该叫做《在 Rust 中复刻 donut.c》。 但由于会完全解释背后的数学原理，并且在 Rust 中实现一个更强的版本 (增强 3D 效果和添加颜色，自动适配终端大小等)，并在最后对 Rust 代码做一点混淆。 我一下子不知道该取什么标题，干脆就叫终端输出甜甜圈这样看起来文不对题的标题。
假如不知道 donut.c 运行输出的效果，下面这个是我在 Rust 中完全复刻输出的效果:
这个是已经增强了光照的，在只有不到 8 fps 的 gif 中效果大打折扣，实际在终端中几十帧的时候相当不错。
总体上来说这篇文章分为两部分，第一部分会详细地介绍背后的数学原理，第二部分会一步步用 Rust 代码实现。 第一部分与原作者不同，我不仅会给出该怎么做，还会给出为什么这么做。 第二部分在用 Rust 实现了 donut 的基础上会选择增强效果以及和原作者一样给出一个混淆的源代码。 混淆后的源代码如下:
use std::{ time, thread,f64};fn main(){let s =f64::consts::PI;let (w,h)= (60,26 );let k= 30.0;let mut l=Vec::new();for i in 0..=11{let c=&amp;#34;.,-~:;=!*#$@&amp;#34;.chars().nth(i) .unwrap();let s=format!(&amp;#34;\x1B[38;5;{}m{}&amp;#34;,233+2*i ,c);l.push(s);} let(mut a,mut b)=(0.0_f64,0.0_f64); println!( &amp;#34;\x1B[2J&amp;#34;); loop {let((c,i),(j,q))=(a. sin_cos(),b.sin_cos( ));let(mut o,mut m) = ( vec!</description></item><item><title>Firewalld快速上手</title><link>https://blog.nidhoggfgg.fun/post/da968c3a/</link><pubDate>Wed, 18 May 2022 23:59:57 +0800</pubDate><guid>https://blog.nidhoggfgg.fun/post/da968c3a/</guid><description>为什么要使用防火墙 不管是个人的电脑还是服务器，防火墙都是很重要的一个部分。 尤其是现在 ipv6 逐渐地是使用广泛，个人的电脑或许不能往内网一放，谁都不能直接从公网攻击到。
就我所在的位置而言，三大运营商的流量都是可以走 ipv6 的，甚至拨号的时候也是默认启用 ipv6 的，这意味着只需要路由器开启就万事具备了。 内网现在也不是安全的，个人开发用的 linux 也是很有必要上防火墙的，更别提服务器了。
linux 上防火墙主要是 iptables 和 firewalld。 他们底层的后端，我没用过，但很显然没必要了解，又不是开发防火墙。 iptables 我没用过，但越来越多的发行版推荐使用 firewalld，那么用 firewalld 就好了，而且 firewalld 使用起来非常简单。
再者，开启防火墙并没有什么坏处，为什么不用呢。
启用启动 启用(开机启动)的话，一般都会带有 unit 文件了，只需要:
sudo systemctl enable firewalld 启动:
sudo systemctl start firewalld 启动之后，firewalld 就已经在工作了！这意味着，除了 22 号端口的 tcp 链接(sshd 服务的端口，默认启用)以外的所有端口不被允许访问。 至此已经足够安全了，毕竟都禁止了。但如果要跑一个 ftp 服务器什么的那么就需要一番配置了。
firewalld 使用 firewalld 主要使用的指令就是 firewall-cmd。 firewall-cmd 必须以 root 权限运行，下文非必要时则省略了 sudo 或者 root 下运行。
区域(zone) firewalld 将网络划分为不同的区域(zone)，不同的区域对应不同的规则，这是为了快速修改防火墙配置。 比如在外面连着公共的网络，这很显然内网是不可信的，应该修改到某个非常严格的配置。 而回到家，连着家里的网络，那么这个就相对可信，可以切换到到不那么严格的配置，这个时候只用切换一下 zone 就好了。</description></item><item><title>Shell中的奇淫巧技</title><link>https://blog.nidhoggfgg.fun/post/8ca21edd/</link><pubDate>Sat, 07 May 2022 21:33:59 +0800</pubDate><guid>https://blog.nidhoggfgg.fun/post/8ca21edd/</guid><description>前言 本文所有内容均在 bash 下进行，在没有特殊说明的情况下 shell 都是指 bash。 一部分内容在 zsh 中会有差异 (存在差异时会指出) 其中尽可能是 shell 的功能，而非某一个软件包所实现的功能 本文的内容默认读者对 shell 已经有一定了解，诸如 $? 或者 ## 这些的含义本文不会赘述。 对于对 shell 不太了解的读者，只希望了解一点点实用技巧，可以阅读 实用技巧 \
奇淫巧技 记录了一些奇奇怪怪、较少使用，但很有趣指令、操作等。 较为实用的部分在 实用技巧 好玩的指令在 just-for-fun
$_ 与 : bash 圣经中的第一个代码示例如下:
trim_string() { # Usage: trim_string &amp;#34; example string &amp;#34; : &amp;#34;${1#&amp;#34;${1%%[![:space:]]*}&amp;#34;}&amp;#34; : &amp;#34;${_%&amp;#34;${_##*[![:space:]]}&amp;#34;}&amp;#34; printf &amp;#39;%s\n&amp;#39; &amp;#34;$_&amp;#34; } 对于字符串的操作比较基础，也有许多文档了，关注点在 : 和 $_ 上。 : 除了扩展后面的那一堆和重定向外，不会执行其他操作1，这里的重定向包括输出到 stdout，并且不会输出。 $_ 和其他脚本语言 (python 之类的) 类似，表示上一个指令执行的结果2 通过这些就可以写一些有趣的代码:
Ծ‸Ծ(){ sleep 0.</description></item><item><title>抓包分析今日校园</title><link>https://blog.nidhoggfgg.fun/post/f35f3418/</link><pubDate>Fri, 27 Aug 2021 13:27:44 +0800</pubDate><guid>https://blog.nidhoggfgg.fun/post/f35f3418/</guid><description>抓包环境 我抓包的环境是 Android 10 真机 + magisk + LSPosed，这样的选择也是无奈之举，缺一不可。
magisk —— 自从 Android 7.0 开始，系统不再信任用户证书，所以我们需要写入系统证书，这需要 system 可写，一般有 root 就差不多了。 到了 Android 11，管得更紧了，system 不能写了，得要 magisk 模块才能写入我们自己的证书。 要抓 https ，导入抓包工具生成的证书是必不可少的。
LSPosed —— 今日校园采用了单向认证的方式来防止抓包，简单点来说就是客户端会校验服务器证书，于是需要一个 xposed 模块来 hook 掉，然后去掉这个校验。 而目前感觉在高版本的安卓上能用上 xposed 并且影响不大的估计就只有 LSPosed 了。 想要抓到关键数据，去除证书校验是必不可少的。
假如是双向校验，同时很难逆向 app ，不妨换个思路，想办法搞到 app 里面的证书然后导入到你所选用的抓包工具中。
而抓出 app 里面的证书，一般只需要解包 app ，查一下资源，没有就去 dex 里面翻一下，也可能在 jni 层里面，一般来说都是一串很长的字符串一样的，比较容易找到，也不需要什么逆向的技术。
假如不能直接找到，但是 so 里面上万的函数，很明显，开发者有意为止，知难而退，不能不知好歹。
当然，也可以选择模拟器，我一般没用模拟器，用的话也只是用一下 VMOS pro，这方面我没有推荐的，都没用过。 pc 上的模拟器或许也不错。
抓包工具 抓包工具我选择的是 burpsuite pro，我笔记本上唯一的抓包工具。
不过我最先开始抓包的时候，是在手机上使用 httpcanary 抓的包，觉得还有很多地方值得测试一下，才开始用 burp 抓包。</description></item></channel></rss>