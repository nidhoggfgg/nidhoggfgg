<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on nothing</title><link>https://blog.nidhoggfgg.fun/posts/</link><description>Recent content in Posts on nothing</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 18 May 2022 23:59:57 +0800</lastBuildDate><atom:link href="https://blog.nidhoggfgg.fun/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Firewalld快速上手</title><link>https://blog.nidhoggfgg.fun/post/da968c3a/</link><pubDate>Wed, 18 May 2022 23:59:57 +0800</pubDate><guid>https://blog.nidhoggfgg.fun/post/da968c3a/</guid><description>为什么要使用防火墙 不管是个人的电脑还是服务器，防火墙都是很重要的一个部分。 尤其是现在 ipv6 逐渐地是使用广泛，个人的电脑或许不能往内网一放，谁都不能直接从公网攻击到。
就我所在的位置而言，三大运营商的流量都是可以走 ipv6 的，甚至拨号的时候也是默认启用 ipv6 的，这意味着只需要路由器开启就万事具备了。 内网现在也不是安全的，个人开发用的 linux 也是很有必要上防火墙的，更别提服务器了。
linux 上防火墙主要是 iptables 和 firewalld。 他们底层的后端，我没用过，但很显然没必要了解，又不是开发防火墙。 iptables 我没用过，但越来越多的发行版推荐使用 firewalld，那么用 firewalld 就好了，而且 firewalld 使用起来非常简单。
再者，开启防火墙并没有什么坏处，为什么不用呢。
启用启动 启用(开机启动)的话，一般都会带有 unit 文件了，只需要:
1 sudo systemctl enable firewalld 启动:
1 sudo systemctl start firewalld 启动之后，firewalld 就已经在工作了！这意味着，除了 22 号端口的 tcp 链接(sshd 服务的端口，默认启用)以外的所有端口不被允许访问。 至此已经足够安全了，毕竟都禁止了。但如果要跑一个 ftp 服务器什么的那么就需要一番配置了。
firewalld 使用 firewalld 主要使用的指令就是 firewall-cmd。 firewall-cmd 必须以 root 权限运行，下文非必要时则省略了 sudo 或者 root 下运行。
区域(zone) firewalld 将网络划分为不同的区域(zone)，不同的区域对应不同的规则，这是为了快速修改防火墙配置。 比如在外面连着公共的网络，这很显然内网是不可信的，应该修改到某个非常严格的配置。 而回到家，连着家里的网络，那么这个就相对可信，可以切换到到不那么严格的配置，这个时候只用切换一下 zone 就好了。</description></item><item><title>Shell中的奇淫巧技</title><link>https://blog.nidhoggfgg.fun/post/8ca21edd/</link><pubDate>Sat, 07 May 2022 21:33:59 +0800</pubDate><guid>https://blog.nidhoggfgg.fun/post/8ca21edd/</guid><description>前言 本文所有内容均在 bash 下进行，并且所说的 shell 都是指 bash，可能有一部分内容在 zsh 不起作用(不起作用时会指出) 文中所用到的 a 目录内容如下
1 2 3 4 5 6 7 8 9 10 11 a ├── test1 │ ├── test3.txt │ └── test4.txt ├── test2 │ ├── test5.txt │ └── test6.txt ├── .what └── .why ├── .emmm └── emmm 并且其中尽可能是 shell 的功能，而非某一个软件包所实现的功能
奇淫巧技 记录了一些奇奇怪怪的指令，操作等。较为实用的部分在实用技巧
$_ 与 : bash圣经中的第一个代码示例如下:
1 2 3 4 5 6 trim_string() { # Usage: trim_string &amp;#34; example string &amp;#34; : &amp;#34;${1#&amp;#34;${1%%[!</description></item><item><title>抓包分析今日校园</title><link>https://blog.nidhoggfgg.fun/post/f35f3418/</link><pubDate>Fri, 27 Aug 2021 13:27:44 +0800</pubDate><guid>https://blog.nidhoggfgg.fun/post/f35f3418/</guid><description>抓包环境 我抓包的环境是 Android 10 真机 + magisk + LSPosed，这样的选择也是无奈之举，缺一不可。
magisk —— 自从 Android 7.0 开始，系统不再信任用户证书，所以我们需要写入系统证书，这需要 system 可写，一般有 root 就差不多了。 到了 Android 11，管得更紧了，system 不能写了，得要 magisk 模块才能写入我们自己的证书。 要抓 https ，导入抓包工具生成的证书是必不可少的。
LSPosed —— 今日校园采用了单向认证的方式来防止抓包，简单点来说就是客户端会校验服务器证书，于是需要一个 xposed 模块来 hook 掉，然后去掉这个校验。 而目前感觉在高版本的安卓上能用上 xposed 并且影响不大的估计就只有 LSPosed 了。 想要抓到关键数据，去除证书校验是必不可少的。
假如是双向校验，同时很难逆向 app ，不妨换个思路，想办法搞到 app 里面的证书然后导入到你所选用的抓包工具中。
而抓出 app 里面的证书，一般只需要解包 app ，查一下资源，没有就去 dex 里面翻一下，也可能在 jni 层里面，一般来说都是一串很长的字符串一样的，比较容易找到，也不需要什么逆向的技术。
假如不能直接找到，但是 so 里面上万的函数，很明显，开发者有意为止，知难而退，不能不知好歹。
当然，也可以选择模拟器，我一般没用模拟器，用的话也只是用一下 VMOS pro，这方面我没有推荐的，都没用过。 pc 上的模拟器或许也不错。
抓包工具 抓包工具我选择的是 burpsuite pro，我笔记本上唯一的抓包工具。
不过我最先开始抓包的时候，是在手机上使用 httpcanary 抓的包，觉得还有很多地方值得测试一下，才开始用 burp 抓包。</description></item></channel></rss>